    // Setup Three.js scene
    scene = new THREE.Scene();
    
    // Setup WebGL renderer
    const canvas = document.getElementById('gameCanvas');
    renderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        antialias: true,
        powerPreference: 'high-performance'
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Set initial loading progress
    updateLoadingProgress(20, "Initializing graphics...");
    
    // Initialize game state
    setTimeout(() => {
        const username = document.getElementById('username').value.trim();
        const faction = document.getElementById('faction').value;
        
        if (username) {
            gameState.player.name = username;
            gameState.player.faction = faction;
            
            // Try to load existing save
            if (!loadGameByUsername(username)) {
                // New game setup
                showNotification(`Welcome, Commander ${username}!`, "success");
                
                // Apply faction starting bonus
                if (faction === 'trader') {
                    gameState.resources.credits += 100;
                } else if (faction === 'miner') {
                    gameState.resources.iron += 50;
                }
            }
        }
        
        updateLoadingProgress(40, "Loading game data...");
    }, 300);
    
    // Setup event listeners
    setTimeout(() => {
        setupEventListeners();
        updateLoadingProgress(60, "Setting up controls...");
    }, 600);
    
    // Create initial planet
    setTimeout(() => {
        currentPlanetData = PLANETS[gameState.currentPlanet];
        createPlanetEnvironment();
        updateLoadingProgress(80, "Generating world...");
    }, 900);
    
    // Final initialization
    setTimeout(() => {
        updateLoadingProgress(95, "Finalizing...");
        
        // Setup camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);
        
        // Setup controls
        setupFirstPersonControls();
        
        // Initialize particle system
        particleSystem = new ParticleSystem(scene);
        
        updateLoadingProgress(100, "Ready!");
        
        // Transition to game
        setTimeout(() => {
            document.getElementById('loadingScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'block';
                gameInitialized = true;
                
                // Start game loop
                animate();
                
                // Start auto-save
                startAutoSaveSystem();
                
                // Show welcome
                showNotification(`Eternal Empire - Ready!`, "success");
                
            }, 500);
        }, 500);
    }, 1200);
}

// ======================
// FIRST PERSON CONTROLS
// ======================
function setupFirstPersonControls() {
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // Create player object
    yawObject = new THREE.Object3D();
    pitchObject = new THREE.Object3D();
    pitchObject.add(camera);
    yawObject.add(pitchObject);
    yawObject.position.set(0, 2, 0);
    scene.add(yawObject);
    
    // Mouse look
    let mouseX = 0, mouseY = 0;
    
    document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === document.body) {
            mouseX += e.movementX * 0.002;
            mouseY += e.movementY * 0.002;
            mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
            
            yawObject.rotation.y = -mouseX;
            pitchObject.rotation.x = -mouseY;
        }
    });
    
    // Pointer lock
    document.addEventListener('click', () => {
        if (!document.pointerLockElement) {
            document.body.requestPointerLock();
        }
    });
    
    // Movement
    const moveSpeed = 0.1;
    const keys = {};
    
    document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        if (e.key === ' ') {
            // Jump
            yawObject.position.y += 0.5;
        }
        
        if (e.key === 'm') {
            toggleMiningMode();
        }
    });
    
    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    // Update movement in game loop
    function updateMovement() {
        if (!yawObject) return;
        
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(yawObject.quaternion);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3(1, 0, 0);
        right.applyQuaternion(yawObject.quaternion);
        right.y = 0;
        right.normalize();
        
        if (keys['w'] || keys['arrowup']) {
            yawObject.position.addScaledVector(forward, moveSpeed);
        }
        if (keys['s'] || keys['arrowdown']) {
            yawObject.position.addScaledVector(forward, -moveSpeed);
        }
        if (keys['a'] || keys['arrowleft']) {
            yawObject.position.addScaledVector(right, -moveSpeed);
        }
        if (keys['d'] || keys['arrowright']) {
            yawObject.position.addScaledVector(right, moveSpeed);
        }
        
        // Keep player on ground
        if (terrain) {
            const raycaster = new THREE.Raycaster(
                new THREE.Vector3(yawObject.position.x, 100, yawObject.position.z),
                new THREE.Vector3(0, -1, 0)
            );
            const intersects = raycaster.intersectObject(terrain);
            if (intersects.length > 0) {
                yawObject.position.y = intersects[0].point.y + 1.6;
            }
        }
    }
    
    // Add to game loop
    const originalAnimate = window.animate;
    window.animate = function() {
        if (originalAnimate) originalAnimate();
        updateMovement();
    };
}

// ======================
// CREATE PLANET ENVIRONMENT
// ======================
function createPlanetEnvironment() {
    // Clear old scene
    while(scene.children.length > 0) {
        scene.remove(scene.children[0]);
    }
    
    // Create terrain
    const terrainGeometry = new THREE.PlaneGeometry(200, 200, 100, 100);
    const terrainMaterial = new THREE.MeshStandardMaterial({ 
        color: currentPlanetData.color,
        roughness: 0.8
    });
    
    terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    terrain.rotation.x = -Math.PI / 2;
    terrain.receiveShadow = true;
    scene.add(terrain);
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Create resources
    createResources();
    
    // Add sky
    scene.background = new THREE.Color(currentPlanetData.skyColor);
    
    // Add fog
    scene.fog = new THREE.Fog(currentPlanetData.skyColor, 50, 200);
}

function createResources() {
    resourceNodes = [];
    
    for (let i = 0; i < 50; i++) {
        const x = Math.random() * 180 - 90;
        const z = Math.random() * 180 - 90;
        const type = getRandomResourceType();
        
        let geometry, material;
        
        switch(type) {
            case 'iron':
                geometry = new THREE.BoxGeometry(1, 1, 1);
                material = new THREE.MeshStandardMaterial({ color: 0x888888 });
                break;
            case 'volcanium':
                geometry = new THREE.ConeGeometry(0.5, 1, 4);
                material = new THREE.MeshStandardMaterial({ color: 0xff5500 });
                break;
            case 'energy':
                geometry = new THREE.SphereGeometry(0.5);
                material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                break;
            default:
                geometry = new THREE.BoxGeometry(1, 1, 1);
                material = new THREE.MeshStandardMaterial({ color: 0x888888 });
        }
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, 0.5, z);
        mesh.castShadow = true;
        scene.add(mesh);
        
        resourceNodes.push({
            mesh: mesh,
            type: type,
            amount: 100,
            collected: false
        });
    }
}

function getRandomResourceType() {
    const resources = Object.keys(currentPlanetData.resources);
    return resources[Math.floor(Math.random() * resources.length)];
}

// ======================
// MINING FUNCTION
// ======================
function mineResourceAtPosition() {
    if (!gameState.player.miningMode || !camera) return;
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    
    const intersects = raycaster.intersectObjects(resourceNodes.map(n => n.mesh));
    
    if (intersects.length > 0) {
        const node = resourceNodes.find(n => n.mesh === intersects[0].object);
        if (node && !node.collected) {
            // Mine the resource
            const amount = Math.min(10, node.amount);
            node.amount -= amount;
            
            // Add to player resources
            switch(node.type) {
                case 'iron':
                    gameState.resources.iron += amount;
                    break;
                case 'volcanium':
                    gameState.resources.volcanium += amount;
                    break;
                case 'energy':
                    gameState.player.energy = Math.min(100, gameState.player.energy + amount);
                    break;
            }
            
            // Visual feedback
            node.mesh.scale.multiplyScalar(0.9);
            
            // Particle effect
            if (particleSystem) {
                particleSystem.createMiningParticles(node.mesh.position, node.mesh.material.color);
            }
            
            // Sound
            audioSystem.playMiningSound();
            
            // Check if depleted
            if (node.amount <= 0) {
                node.collected = true;
                scene.remove(node.mesh);
            }
            
            // Update UI
            updateUI();
            
            // Show notification
            showNotification(`Mined ${amount} ${node.type}!`, "success");
            
            // Gain XP
            gameState.player.experience += amount;
            checkLevelUp();
        }
    }
}

// ======================
// GAME LOOP
// ======================
function animate() {
    requestAnimationFrame(animate);
    
    if (!gameInitialized) return;
    
    // Update resource animations
    resourceNodes.forEach(node => {
        if (node.mesh && !node.collected) {
            node.mesh.rotation.y += 0.01;
            node.mesh.position.y = Math.sin(Date.now() * 0.001 + node.mesh.position.x) * 0.1 + 0.5;
        }
    });
    
    // Update UI periodically
    if (Math.floor(Date.now() / 1000) % 5 === 0) {
        updateUI();
    }
    
    // Render
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

// ======================
// UI FUNCTIONS
// ======================
function updateUI() {
    // Update resource displays
    document.getElementById('ironDisplay').textContent = gameState.resources.iron;
    document.getElementById('volcaniumDisplay').textContent = gameState.resources.volcanium;
    document.getElementById('energyDisplay').textContent = Math.floor(gameState.player.energy);
    document.getElementById('creditsDisplay').textContent = gameState.resources.credits;
    
    // Update player info
    document.getElementById('playerNameDisplay').textContent = gameState.player.name;
    document.getElementById('levelDisplay').textContent = gameState.player.level;
    document.getElementById('currentPlanetDisplay').textContent = currentPlanetData.name;
    
    // Update health/energy bars
    const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
    const energyPercent = (gameState.player.energy / gameState.player.maxEnergy) * 100;
    
    document.getElementById('healthFill').style.width = `${healthPercent}%`;
    document.getElementById('energyFill').style.width = `${energyPercent}%`;
    document.getElementById('healthValue').textContent = Math.floor(gameState.player.health);
    document.getElementById('energyValue').textContent = Math.floor(gameState.player.energy);
}

function showNotification(message, type = "info", duration = 3000) {
    const notificationCenter = document.getElementById('notificationCenter');
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;
    
    notificationCenter.appendChild(notification);
    
    // Remove after duration
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, duration);
}

// ======================
// LEVEL UP SYSTEM
// ======================
function checkLevelUp() {
    const neededExp = gameState.player.level * 100;
    if (gameState.player.experience >= neededExp) {
        gameState.player.level++;
        gameState.player.experience = 0;
        gameState.player.maxHealth += 10;
        gameState.player.maxEnergy += 10;
        
        showNotification(`ðŸŽ‰ Level Up! Now Level ${gameState.player.level}`, "success", 4000);
        updateUI();
    }
}

// ======================
// EVENT LISTENERS SETUP
// ======================
function setupEventListeners() {
    // Launch button
    document.getElementById('launchButton').addEventListener('click', () => {
        const username = document.getElementById('username').value.trim();
        if (!username) {
            showNotification("Please enter a commander name!", "warning");
            return;
        }
        
        document.getElementById('loginScreen').style.display = 'none';
        document.getElementById('loadingScreen').style.display = 'flex';
        
        setTimeout(() => {
            initGame();
        }, 100);
    });
    
    // Guide button
    document.getElementById('guideButton').addEventListener('click', () => {
        document.getElementById('guideModal').style.display = 'flex';
    });
    
    document.getElementById('closeGuideBtn').addEventListener('click', () => {
        document.getElementById('guideModal').style.display = 'none';
    });
    
    // Mining mode toggle
    document.getElementById('miningModeBtn').addEventListener('click', toggleMiningMode);
    
    // Quick actions
    document.getElementById('quickMineBtn').addEventListener('click', toggleMiningMode);
    document.getElementById('quickBuildBtn').addEventListener('click', () => {
        document.getElementById('buildingMenu').style.display = 'flex';
    });
    
    // Planet selection
    document.querySelectorAll('.planet-card').forEach(card => {
        card.addEventListener('click', () => {
            const planetId = card.getAttribute('data-planet');
            selectPlanet(planetId);
        });
    });
    
    // Building selection
    document.querySelectorAll('.building-card').forEach(card => {
        card.addEventListener('click', () => {
            const buildingType = card.getAttribute('data-building');
            buildStructure(buildingType);
        });
    });
    
    // Mobile controls
    setupMobileControls();
}

function setupMobileControls() {
    const joystickArea = document.getElementById('joystickArea');
    const joystickHandle = document.getElementById('joystickHandle');
    
    let active = false;
    let startX = 0, startY = 0;
    let currentX = 0, currentY = 0;
    
    joystickArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        active = true;
        const touch = e.touches[0];
        const rect = joystickArea.getBoundingClientRect();
        startX = rect.left + rect.width / 2;
        startY = rect.top + rect.height / 2;
    });
    
    joystickArea.addEventListener('touchmove', (e) => {
        if (!active) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        currentX = touch.clientX - startX;
        currentY = touch.clientY - startY;
        
        // Limit movement
        const maxDist = 60;
        const dist = Math.sqrt(currentX * currentX + currentY * currentY);
        if (dist > maxDist) {
            currentX = (currentX / dist) * maxDist;
            currentY = (currentY / dist) * maxDist;
        }
        
        // Update visual
        joystickHandle.style.transform = `translate(${currentX}px, ${currentY}px)`;
        
        // Update movement vector
        movementVector.x = currentX / maxDist;
        movementVector.z = currentY / maxDist;
    });
    
    joystickArea.addEventListener('touchend', () => {
        active = false;
        currentX = currentY = 0;
        joystickHandle.style.transform = 'translate(0, 0)';
        movementVector.x = movementVector.z = 0;
    });
    
    // Mobile action buttons
    document.getElementById('jumpButton').addEventListener('click', () => {
        if (yawObject) {
            yawObject.position.y += 0.5;
        }
    });
    
    document.getElementById('mineButton').addEventListener('click', () => {
        if (gameState.player.miningMode) {
            mineResourceAtPosition();
        } else {
            toggleMiningMode();
        }
    });
}

// ======================
// PLANET FUNCTIONS
// ======================
function selectPlanet(planetId) {
    if (!gameState.unlockedPlanets.includes(planetId)) {
        showNotification(`Planet ${PLANETS[planetId].name} is locked!`, "warning");
        return;
    }
    
    currentPlanetData = PLANETS[planetId];
    gameState.currentPlanet = planetId;
    
    // Recreate environment
    createPlanetEnvironment();
    
    showNotification(`Traveled to ${currentPlanetData.name}!`, "success");
    updateUI();
    
    // Close selection
    document.getElementById('planetSelection').style.display = 'none';
}

// ======================
// BUILDING FUNCTIONS
// ======================
function buildStructure(buildingType) {
    const building = BUILDINGS[buildingType];
    
    if (gameState.resources.iron < building.cost.iron) {
        showNotification(`Need ${building.cost.iron} iron!`, "warning");
        return;
    }
    
    gameState.resources.iron -= building.cost.iron;
    
    // Create building
    const buildingData = {
        type: buildingType,
        position: { x: 0, y: 0, z: 0 },
        level: 1
    };
    
    gameState.buildings.push(buildingData);
    
    showNotification(`${building.name} built!`, "success");
    updateUI();
    
    // Close menu
    document.getElementById('buildingMenu').style.display = 'none';
}

// ======================
// AUTO-SAVE SYSTEM
// ======================
function startAutoSaveSystem() {
    // Auto-save every 30 seconds
    setInterval(() => {
        if (gameInitialized) {
            autoSaveGame();
        }
    }, 30000);
    
    // Also save on page unload
    window.addEventListener('beforeunload', autoSaveGame);
}

function autoSaveGame() {
    try {
        // Update player position
        if (yawObject) {
            gameState.player.position = {
                x: yawObject.position.x,
                y: yawObject.position.y,
                z: yawObject.position.z
            };
        }
        
        // Save to localStorage
        localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
        
        // Show indicator
        const indicator = document.getElementById('autoSaveIndicator');
        indicator.style.display = 'block';
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 2000);
        
    } catch (error) {
        console.error("Save failed:", error);
    }
}

// ======================
// WINDOW RESIZE
// ======================
window.addEventListener('resize', () => {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
});

// ======================
// START THE GAME
// ======================
// Initialize when page loads
window.addEventListener('DOMContentLoaded', () => {
    console.log("Eternal Empire - Loading...");
    
    // Hide loading screen after 2 seconds
    setTimeout(() => {
        document.getElementById('loadingScreen').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('loginScreen').style.display = 'flex';
        }, 500);
    }, 2000);
});
